<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Dilation Debugger</title>
  <style>
    canvas {
      margin: 10px;
      border: 1px solid black;
    }
  </style>
</head>
<body>
  <canvas id="originalCanvas"></canvas>
  <canvas id="dilationCanvas"></canvas>
  <script>
    const originalCanvas = document.getElementById('originalCanvas');
    const dilationCanvas = document.getElementById('dilationCanvas');
    const originalCtx = originalCanvas.getContext('2d');
    const dilationCtx = dilationCanvas.getContext('2d');

    const img = new Image();
    img.src = 'img/test.jpg'; // Substitua pelo caminho da imagem gerada
    img.onload = () => {
      originalCanvas.width = dilationCanvas.width = img.width;
      originalCanvas.height = dilationCanvas.height = img.height;
      originalCtx.drawImage(img, 0, 0);

      const imageData = originalCtx.getImageData(0, 0, originalCanvas.width, originalCanvas.height);
      const grayscaleData = applyGrayscale(imageData);
      const binaryData = applyThreshold(grayscaleData, 128);
      dilationCtx.putImageData(binaryData, 0, 0);
      applyDilationStepByStep(binaryData, 1); // Aplica 1 iteração de dilatação para teste
    };

    function applyGrayscale(imageData) {
      const data = imageData.data;
      for (let i = 0; i < data.length; i += 4) {
        const avg = (data[i] + data[i + 1] + data[i + 2]) / 3;
        data[i] = avg;
        data[i + 1] = avg;
        data[i + 2] = avg;
      }
      return imageData;
    }

    function applyThreshold(imageData, threshold) {
      const data = imageData.data;
      for (let i = 0; i < data.length; i += 4) {
        const value = data[i] > threshold ? 255 : 0;
        data[i] = value;
        data[i + 1] = value;
        data[i + 2] = value;
      }
      return imageData;
    }

    function applyDilationStepByStep(imageData, iterations) {
      const width = imageData.width;
      const height = imageData.height;
      let data = imageData.data;
      const kernel = [
        [0, 1, 0],
        [1, 1, 1],
        [0, 1, 0]
      ];

      const output = dilationCtx.createImageData(width, height);
      const outputData = output.data;

      // Initialize output with original data
      for (let i = 0; i < data.length; i++) {
        outputData[i] = data[i];
      }

      function dilateStep(step, x, y) {
        if (step >= iterations) return;

        if (x < width && y < height) {
          // Process the current pixel
          let max = 0;
          for (let ky = -1; ky <= 1; ky++) {
            for (let kx = -1; kx <= 1; kx++) {
              const xk = x + kx;
              const yk = y + ky;
              if (xk >= 0 && xk < width && yk >= 0 && yk < height) {
                const index = (yk * width + xk) * 4;
                if (kernel[ky + 1][kx + 1] === 1) {
                  max = Math.max(max, data[index]);
                }
              }
            }
          }
          const index = (y * width + x) * 4;
          outputData[index] = max;
          outputData[index + 1] = max;
          outputData[index + 2] = max;
          outputData[index + 3] = data[index + 3]; // Preserve alpha channel

          // Draw the processed part of the image
          dilationCtx.putImageData(output, 0, 0);

          // Highlight the current kernel position
          dilationCtx.strokeStyle = 'red';
          dilationCtx.lineWidth = 2;
          dilationCtx.strokeRect(x - 1, y - 1, 3, 3);

          // Move to the next pixel
          setTimeout(() => {
            let nextX = x + 1;
            let nextY = y;
            if (nextX >= width) {
              nextX = 0;
              nextY = y + 1;
            }
            requestAnimationFrame(() => dilateStep(step, nextX, nextY));
          }, 5);
        } else {
          // Move to the next iteration if the current one is done
          requestAnimationFrame(() => dilateStep(step + 1, 0, 0));
        }
      }

      dilateStep(0, 0, 0);
    }
  </script>
</body>
</html>
